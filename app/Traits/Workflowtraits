<?php

namespace App\Traits;

use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\MorphMany;
use Illuminate\Support\Facades\Log;

/**
 * HasWorkflow Trait
 *
 * Provides workflow state management for any model.
 * Handles state transitions, approval workflows, and audit trails.
 */
trait HasWorkflow
{
    /**
     * Boot the HasWorkflow trait
     */
    protected static function bootHasWorkflow(): void
    {
        static::creating(function (Model $model) {
            if (!isset($model->attributes['workflow_state'])) {
                $model->workflow_state = $model->getInitialWorkflowState();
            }
        });

        static::updating(function (Model $model) {
            if ($model->isDirty('status')) {
                $model->recordWorkflowTransition(
                    $model->getOriginal('status'),
                    $model->status
                );
            }
        });
    }

    /**
     * Get workflow history for this model
     */
    public function workflowHistory(): MorphMany
    {
        return $this->morphMany(WorkflowHistory::class, 'workflowable');
    }

    /**
     * Get current workflow state
     */
    public function workflowState(): MorphOne
    {
        return $this->morphOne(WorkflowState::class, 'workflowable');
    }

    /**
     * Get the initial workflow state for new records
     */
    public function getInitialWorkflowState(): array
    {
        return [
            'current_step' => 1,
            'total_steps' => $this->getTotalWorkflowSteps(),
            'status' => $this->getInitialStatus(),
            'metadata' => [],
            'started_at' => now(),
        ];
    }

    /**
     * Get initial status based on model type
     */
    protected function getInitialStatus(): string
    {
        return match(get_class($this)) {
            'App\Models\Project\Project' => 'draft',
            'App\Models\Budget\Budget' => 'draft',
            'App\Models\Procurement\Procurement' => 'planning',
            default => 'pending'
        };
    }

    /**
     * Get total workflow steps based on model and methodology
     */
    protected function getTotalWorkflowSteps(): int
    {
        if (method_exists($this, 'getWorkflowSteps')) {
            return count($this->getWorkflowSteps());
        }

        // Default workflow steps
        return match(get_class($this)) {
            'App\Models\Project\Project' => $this->getProjectWorkflowSteps(),
            'App\Models\Budget\Budget' => $this->getBudgetWorkflowSteps(),
            default => 3
        };
    }

    /**
     * Get project-specific workflow steps based on methodology
     */
    protected function getProjectWorkflowSteps(): int
    {
        $methodology = $this->methodology_type ?? 'universal';
       
        return match($methodology) {
            'usaid' => 6, // Draft -> Review -> Compliance -> Approval -> Active -> Completed
            'world_bank' => 8, // Additional safeguards and quality gates
            'eu' => 5, // Standard EU workflow
            default => 4 // Universal workflow
        };
    }

    /**
     * Get budget workflow steps
     */
    protected function getBudgetWorkflowSteps(): int
    {
        $amount = $this->budget ?? $this->total_amount ?? 0;
       
        // More approval steps for larger budgets
        if ($amount > 1000000) return 5; // Executive approval required
        if ($amount > 100000) return 4;  // Department head approval
        return 3; // Standard approval
    }

    /**
     * Check if model can transition to new status
     */
    public function canTransitionTo(string $newStatus): bool
    {
        $currentStatus = $this->status;
        $allowedTransitions = $this->getAllowedTransitions();
       
        return in_array($newStatus, $allowedTransitions[$currentStatus] ?? []);
    }

    /**
     * Get allowed transitions for current status
     */
    public function getAllowedTransitions(): array
    {
        if (method_exists($this, 'getModelTransitions')) {
            return $this->getModelTransitions();
        }

        // Default transitions for projects
        if (get_class($this) === 'App\Models\Project\Project') {
            return $this->getProjectTransitions();
        }

        // Default generic transitions
        return [
            'draft' => ['pending_approval', 'cancelled'],
            'pending_approval' => ['approved', 'rejected', 'draft'],
            'approved' => ['active', 'cancelled'],
            'active' => ['completed', 'on_hold', 'cancelled'],
            'on_hold' => ['active', 'cancelled'],
            'completed' => [],
            'cancelled' => ['draft'],
            'rejected' => ['draft', 'cancelled']
        ];
    }

    /**
     * Get project-specific transitions
     */
    protected function getProjectTransitions(): array
    {
        $methodology = $this->methodology_type ?? 'universal';
       
        $baseTransitions = [
            'draft' => ['pending_approval', 'cancelled'],
            'pending_approval' => ['approved', 'rejected', 'draft'],
            'approved' => ['active', 'cancelled'],
            'active' => ['on_hold', 'completed', 'cancelled'],
            'on_hold' => ['active', 'cancelled'],
            'completed' => [],
            'cancelled' => ['draft'],
            'rejected' => ['draft', 'cancelled']
        ];

        // Add methodology-specific transitions
        if ($methodology === 'usaid') {
            $baseTransitions['approved'] = ['compliance_review', 'cancelled'];
            $baseTransitions['compliance_review'] = ['active', 'pending_approval'];
        }

        if ($methodology === 'world_bank') {
            $baseTransitions['approved'] = ['safeguards_review', 'cancelled'];
            $baseTransitions['safeguards_review'] = ['quality_review', 'pending_approval'];
            $baseTransitions['quality_review'] = ['active', 'safeguards_review'];
        }

        return $baseTransitions;
    }

    /**
     * Transition to new status with validation
     */
    public function transitionTo(string $newStatus, array $metadata = [], ?int $userId = null): bool
    {
        if (!$this->canTransitionTo($newStatus)) {
            Log::warning('Invalid workflow transition attempted', [
                'model' => get_class($this),
                'id' => $this->id,
                'from' => $this->status,
                'to' => $newStatus,
                'user_id' => $userId
            ]);
            return false;
        }

        $oldStatus = $this->status;
       
        // Perform pre-transition validation
        if (!$this->validateTransition($oldStatus, $newStatus)) {
            return false;
        }

        // Update status
        $this->status = $newStatus;
        $this->save();

        // Record transition
        $this->recordWorkflowTransition($oldStatus, $newStatus, $metadata, $userId);

        // Perform post-transition actions
        $this->executeTransitionActions($oldStatus, $newStatus);

        return true;
    }

    /**
     * Validate transition requirements
     */
    protected function validateTransition(string $fromStatus, string $toStatus): bool
    {
        // Project-specific validation
        if (get_class($this) === 'App\Models\Project\Project') {
            return $this->validateProjectTransition($fromStatus, $toStatus);
        }

        // Default validation (always true)
        return true;
    }

    /**
     * Validate project transition requirements
     */
    protected function validateProjectTransition(string $fromStatus, string $toStatus): bool
    {
        switch ($toStatus) {
            case 'approved':
                // Check all required fields are completed
                return $this->hasRequiredApprovalData();
               
            case 'active':
                // Check project has milestones and budget
                return $this->milestones()->exists() && $this->budget > 0;
               
            case 'completed':
                // Check all milestones are completed
                return !$this->milestones()->whereNotIn('status', ['completed', 'cancelled'])->exists();
               
            default:
                return true;
        }
    }

    /**
     * Check if project has required data for approval
     */
    protected function hasRequiredApprovalData(): bool
    {
        $required = ['name', 'description', 'start_date', 'end_date', 'budget'];
       
        foreach ($required as $field) {
            if (empty($this->$field)) {
                return false;
            }
        }

        // Methodology-specific requirements
        if ($this->methodology_type === 'usaid') {
            $compliance = $this->compliance_requirements ?? [];
            if ($this->budget > 100000 && !($compliance['environmental_screening'] ?? false)) {
                return false;
            }
        }

        return true;
    }

    /**
     * Record workflow transition in history
     */
    protected function recordWorkflowTransition(
        string $fromStatus,
        string $toStatus,
        array $metadata = [],
        ?int $userId = null
    ): void {
        $this->workflowHistory()->create([
            'from_status' => $fromStatus,
            'to_status' => $toStatus,
            'user_id' => $userId ?? auth()->id(),
            'metadata' => $metadata,
            'transitioned_at' => now(),
            'tenant_id' => $this->tenant_id ?? app('tenant')?->id
        ]);

        // Update workflow state
        $this->updateWorkflowState($toStatus);
    }

    /**
     * Update current workflow state
     */
    protected function updateWorkflowState(string $newStatus): void
    {
        $workflowState = $this->workflowState ?? new WorkflowState();
       
        $currentStep = $this->calculateCurrentStep($newStatus);
       
        $workflowState->fill([
            'workflowable_type' => get_class($this),
            'workflowable_id' => $this->id,
            'current_step' => $currentStep,
            'total_steps' => $this->getTotalWorkflowSteps(),
            'status' => $newStatus,
            'progress_percentage' => ($currentStep / $this->getTotalWorkflowSteps()) * 100,
            'metadata' => [
                'last_transition' => now(),
                'methodology' => $this->methodology_type ?? 'universal'
            ],
            'tenant_id' => $this->tenant_id ?? app('tenant')?->id
        ]);

        $workflowState->save();
    }

    /**
     * Calculate current workflow step based on status
     */
    protected function calculateCurrentStep(string $status): int
    {
        $stepMapping = $this->getStatusStepMapping();
        return $stepMapping[$status] ?? 1;
    }

    /**
     * Get status to step mapping
     */
    protected function getStatusStepMapping(): array
    {
        if (get_class($this) === 'App\Models\Project\Project') {
            return $this->getProjectStatusStepMapping();
        }

        // Default mapping
        return [
            'draft' => 1,
            'pending_approval' => 2,
            'approved' => 3,
            'active' => 4,
            'completed' => 5,
            'cancelled' => 0,
            'rejected' => 0
        ];
    }

    /**
     * Get project status to step mapping
     */
    protected function getProjectStatusStepMapping(): array
    {
        $methodology = $this->methodology_type ?? 'universal';
       
        $mapping = [
            'draft' => 1,
            'pending_approval' => 2,
            'approved' => 3,
            'active' => 4,
            'completed' => 5,
            'cancelled' => 0,
            'rejected' => 0
        ];

        // Add methodology-specific steps
        if ($methodology === 'usaid') {
            $mapping['compliance_review'] = 3;
            $mapping['approved'] = 4;
            $mapping['active'] = 5;
            $mapping['completed'] = 6;
        }

        if ($methodology === 'world_bank') {
            $mapping['safeguards_review'] = 3;
            $mapping['quality_review'] = 4;
            $mapping['approved'] = 5;
            $mapping['active'] = 6;
            $mapping['completed'] = 7;
        }

        return $mapping;
    }

    /**
     * Execute post-transition actions
     */
    protected function executeTransitionActions(string $fromStatus, string $toStatus): void
    {
        // Fire transition events
        event("workflow.transitioned.{$toStatus}", [$this, $fromStatus, $toStatus]);
       
        // Execute specific actions based on transition
        match($toStatus) {
            'pending_approval' => $this->notifyApprovers(),
            'approved' => $this->notifyStakeholders('approved'),
            'active' => $this->activateProject(),
            'completed' => $this->finalizeProject(),
            'cancelled' => $this->cancelProject(),
            default => null
        };
    }

    /**
     * Notify approvers when project needs approval
     */
    protected function notifyApprovers(): void
    {
        if (method_exists($this, 'getApprovers')) {
            $approvers = $this->getApprovers();
            foreach ($approvers as $approver) {
                // Send notification (implement based on your notification system)
                // Notification::send($approver, new ProjectPendingApproval($this));
            }
        }
    }

    /**
     * Notify stakeholders of status change
     */
    protected function notifyStakeholders(string $status): void
    {
        if (method_exists($this, 'stakeholders')) {
            $stakeholders = $this->stakeholders;
            foreach ($stakeholders as $stakeholder) {
                // Send notification
                // Notification::send($stakeholder, new ProjectStatusChanged($this, $status));
            }
        }
    }

    /**
     * Actions to perform when project becomes active
     */
    protected function activateProject(): void
    {
        if (get_class($this) === 'App\Models\Project\Project') {
            // Set actual start date if not set
            if (!$this->actual_start_date) {
                $this->update(['actual_start_date' => now()]);
            }
           
            // Initialize project tracking
            // $this->initializeProjectTracking();
        }
    }

    /**
     * Actions to perform when project is completed
     */
    protected function finalizeProject(): void
    {
        if (get_class($this) === 'App\Models\Project\Project') {
            // Set actual end date
            $this->update(['actual_end_date' => now()]);
           
            // Generate completion report
            // $this->generateCompletionReport();
        }
    }

    /**
     * Actions to perform when project is cancelled
     */
    protected function cancelProject(): void
    {
        if (get_class($this) === 'App\Models\Project\Project') {
            // Cancel pending milestones
            $this->milestones()
                ->whereNotIn('status', ['completed', 'cancelled'])
                ->update(['status' => 'cancelled']);
        }
    }

    /**
     * Get workflow progress information
     */
    public function getWorkflowProgress(): array
    {
        $workflowState = $this->workflowState;
       
        if (!$workflowState) {
            return [
                'current_step' => 1,
                'total_steps' => $this->getTotalWorkflowSteps(),
                'progress_percentage' => 0,
                'status' => $this->status,
                'next_steps' => $this->getAllowedTransitions()[$this->status] ?? []
            ];
        }

        return [
            'current_step' => $workflowState->current_step,
            'total_steps' => $workflowState->total_steps,
            'progress_percentage' => $workflowState->progress_percentage,
            'status' => $workflowState->status,
            'next_steps' => $this->getAllowedTransitions()[$this->status] ?? [],
            'last_transition' => $workflowState->metadata['last_transition'] ?? null
        ];
    }

    /**
     * Get workflow timeline
     */
    public function getWorkflowTimeline(): array
    {
        return $this->workflowHistory()
            ->orderBy('transitioned_at')
            ->get()
            ->map(function ($transition) {
                return [
                    'from_status' => $transition->from_status,
                    'to_status' => $transition->to_status,
                    'transitioned_at' => $transition->transitioned_at,
                    'user' => $transition->user?->name ?? 'System',
                    'metadata' => $transition->metadata
                ];
            })
            ->toArray();
    }

    /**
     * Check if workflow is in final state
     */
    public function isWorkflowComplete(): bool
    {
        $finalStates = ['completed', 'cancelled', 'rejected'];
        return in_array($this->status, $finalStates);
    }

    /**
     * Get workflow approval chain
     */
    public function getApprovalChain(): array
    {
        // This should be implemented based on your organization structure
        // and methodology requirements
       
        $methodology = $this->methodology_type ?? 'universal';
        $budget = $this->budget ?? 0;
       
        $chain = [];
       
        // Basic approval chain
        $chain[] = ['role' => 'project_manager', 'required' => true];
       
        if ($budget > 50000) {
            $chain[] = ['role' => 'finance_officer', 'required' => true];
        }
       
        if ($budget > 100000) {
            $chain[] = ['role' => 'department_head', 'required' => true];
        }
       
        // Methodology-specific approvers
        if ($methodology === 'usaid' && $budget > 100000) {
            $chain[] = ['role' => 'compliance_officer', 'required' => true];
            $chain[] = ['role' => 'environmental_officer', 'required' => true];
        }
       
        if ($methodology === 'world_bank') {
            $chain[] = ['role' => 'safeguards_specialist', 'required' => true];
            $chain[] = ['role' => 'quality_reviewer', 'required' => true];
        }
       
        if ($budget > 1000000) {
            $chain[] = ['role' => 'executive_director', 'required' => true];
        }
       
        return $chain;
    }

    /**
     * Reset workflow to initial state
     */
    public function resetWorkflow(): void
    {
        $this->status = $this->getInitialStatus();
        $this->save();
       
        // Clear workflow state
        $this->workflowState()?->delete();
       
        // Add reset entry to history
        $this->recordWorkflowTransition(
            'reset',
            $this->status,
            ['reason' => 'workflow_reset'],
            auth()->id()
        );
    }
}

/**
 * WorkflowHistory Model
 *
 * Stores the complete history of workflow transitions
 */
class WorkflowHistory extends Model
{
    use BelongsToTenant;

    protected $fillable = [
        'workflowable_type',
        'workflowable_id',
        'from_status',
        'to_status',
        'user_id',
        'metadata',
        'transitioned_at',
        'tenant_id'
    ];

    protected $casts = [
        'metadata' => 'array',
        'transitioned_at' => 'datetime'
    ];

    public function workflowable()
    {
        return $this->morphTo();
    }

    public function user()
    {
        return $this->belongsTo(User::class);
    }
}

/**
 * WorkflowState Model
 *
 * Stores the current workflow state for efficient querying
 */
class WorkflowState extends Model
{
    use BelongsToTenant;

    protected $fillable = [
        'workflowable_type',
        'workflowable_id',
        'current_step',
        'total_steps',
        'status',
        'progress_percentage',
        'metadata',
        'tenant_id'
    ];

    protected $casts = [
        'current_step' => 'integer',
        'total_steps' => 'integer',
        'progress_percentage' => 'decimal:2',
        'metadata' => 'array'
    ];

    public function workflowable()
    {
        return $this->morphTo();
    }
}